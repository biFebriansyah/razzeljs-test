{"ast":null,"code":"import _asyncToGenerator from \"/home/ab/Code/reactJs/razzel/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _regeneratorRuntime from \"/home/ab/Code/reactJs/razzel/node_modules/@babel/runtime/regenerator\";\n\nvar createImage = function createImage(url) {\n  return new Promise(function (resolve, reject) {\n    var image = new Image();\n    image.addEventListener(\"load\", function () {\n      return resolve(image);\n    });\n    image.addEventListener(\"error\", function (error) {\n      return reject(error);\n    });\n    image.setAttribute(\"crossOrigin\", \"anonymous\"); // needed to avoid cross-origin issues on CodeSandbox\n\n    image.src = url;\n  });\n};\n\nfunction getRadianAngle(degreeValue) {\n  return degreeValue * Math.PI / 180;\n}\n/**\n * This function was adapted from the one in the ReadMe of https://github.com/DominicTobias/react-image-crop\n * @param {File} image - Image File url\n * @param {Object} pixelCrop - pixelCrop Object provided by react-easy-crop\n * @param {number} rotation - optional rotation parameter\n */\n\n\nexport default function getCroppedImg(_x, _x2) {\n  return _getCroppedImg.apply(this, arguments);\n}\n\nfunction _getCroppedImg() {\n  _getCroppedImg = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(imageSrc, pixelCrop) {\n    var rotation,\n        image,\n        canvas,\n        ctx,\n        maxSize,\n        safeArea,\n        data,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            rotation = _args.length > 2 && _args[2] !== undefined ? _args[2] : 0;\n            _context.next = 3;\n            return createImage(imageSrc);\n\n          case 3:\n            image = _context.sent;\n            canvas = document.createElement(\"canvas\");\n            ctx = canvas.getContext(\"2d\");\n            maxSize = Math.max(image.width, image.height);\n            safeArea = 2 * (maxSize / 2 * Math.sqrt(2)); // set each dimensions to double largest dimension to allow for a safe area for the\n            // image to rotate in without being clipped by canvas context\n\n            canvas.width = safeArea;\n            canvas.height = safeArea; // translate canvas context to a central location on image to allow rotating around the center.\n\n            ctx.translate(safeArea / 2, safeArea / 2);\n            ctx.rotate(getRadianAngle(rotation));\n            ctx.translate(-safeArea / 2, -safeArea / 2); // draw rotated image and store data.\n\n            ctx.drawImage(image, safeArea / 2 - image.width * 0.5, safeArea / 2 - image.height * 0.5);\n            data = ctx.getImageData(0, 0, safeArea, safeArea); // set canvas width to final desired crop size - this will clear existing context\n\n            canvas.width = pixelCrop.width;\n            canvas.height = pixelCrop.height; // paste generated rotate image with correct offsets for x,y crop values.\n\n            ctx.putImageData(data, Math.round(0 - safeArea / 2 + image.width * 0.5 - pixelCrop.x), Math.round(0 - safeArea / 2 + image.height * 0.5 - pixelCrop.y)); // As Base64 string\n            // return canvas.toDataURL(\"image/jpeg\")\n            // As a blob\n\n            return _context.abrupt(\"return\", new Promise(function (resolve) {\n              canvas.toBlob(function (file) {\n                var images = URL.createObjectURL(file);\n                resolve({\n                  file: file,\n                  image: images\n                }); // resolve(URL.createObjectURL(file))\n              }, \"image/jpeg\");\n            }));\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getCroppedImg.apply(this, arguments);\n}","map":{"version":3,"sources":["/home/ab/Code/reactJs/razzel/src/helpers/cropImage.js"],"names":["createImage","url","Promise","resolve","reject","image","Image","addEventListener","error","setAttribute","src","getRadianAngle","degreeValue","Math","PI","getCroppedImg","imageSrc","pixelCrop","rotation","canvas","document","createElement","ctx","getContext","maxSize","max","width","height","safeArea","sqrt","translate","rotate","drawImage","data","getImageData","putImageData","round","x","y","toBlob","file","images","URL","createObjectURL"],"mappings":"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","sourcesContent":["const createImage = (url) =>\n    new Promise((resolve, reject) => {\n        const image = new Image()\n        image.addEventListener(\"load\", () => resolve(image))\n        image.addEventListener(\"error\", (error) => reject(error))\n        image.setAttribute(\"crossOrigin\", \"anonymous\") // needed to avoid cross-origin issues on CodeSandbox\n        image.src = url\n    })\n\nfunction getRadianAngle(degreeValue) {\n    return (degreeValue * Math.PI) / 180\n}\n\n/**\n * This function was adapted from the one in the ReadMe of https://github.com/DominicTobias/react-image-crop\n * @param {File} image - Image File url\n * @param {Object} pixelCrop - pixelCrop Object provided by react-easy-crop\n * @param {number} rotation - optional rotation parameter\n */\nexport default async function getCroppedImg(imageSrc, pixelCrop, rotation = 0) {\n    const image = await createImage(imageSrc)\n    const canvas = document.createElement(\"canvas\")\n    const ctx = canvas.getContext(\"2d\")\n\n    const maxSize = Math.max(image.width, image.height)\n    const safeArea = 2 * ((maxSize / 2) * Math.sqrt(2))\n\n    // set each dimensions to double largest dimension to allow for a safe area for the\n    // image to rotate in without being clipped by canvas context\n    canvas.width = safeArea\n    canvas.height = safeArea\n\n    // translate canvas context to a central location on image to allow rotating around the center.\n    ctx.translate(safeArea / 2, safeArea / 2)\n    ctx.rotate(getRadianAngle(rotation))\n    ctx.translate(-safeArea / 2, -safeArea / 2)\n\n    // draw rotated image and store data.\n    ctx.drawImage(image, safeArea / 2 - image.width * 0.5, safeArea / 2 - image.height * 0.5)\n    const data = ctx.getImageData(0, 0, safeArea, safeArea)\n\n    // set canvas width to final desired crop size - this will clear existing context\n    canvas.width = pixelCrop.width\n    canvas.height = pixelCrop.height\n\n    // paste generated rotate image with correct offsets for x,y crop values.\n    ctx.putImageData(\n        data,\n        Math.round(0 - safeArea / 2 + image.width * 0.5 - pixelCrop.x),\n        Math.round(0 - safeArea / 2 + image.height * 0.5 - pixelCrop.y)\n    )\n\n    // As Base64 string\n    // return canvas.toDataURL(\"image/jpeg\")\n\n    // As a blob\n    return new Promise((resolve) => {\n        canvas.toBlob((file) => {\n            const images = URL.createObjectURL(file)\n            resolve({ file: file, image: images })\n            // resolve(URL.createObjectURL(file))\n        }, \"image/jpeg\")\n    })\n}\n"]},"metadata":{},"sourceType":"module"}